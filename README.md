# Very efficient hexadecimal to ASCII conversion
## Introduction
Dennis R. Allison, in his article ["A Design Philosophy for Microcomputer Architectures", Computer, February 1977](https://www.computer.org/csdl/magazine/co/1977/02/01646378/13rRUEgs2vU),
discussed the challenge of using high-level languages to overcome
the paucity of software for microcomputers of that time. But he
argued that compilers for high-level languages could not achieve
the same efficiency as well-crafted assembly language. According
to Allison ...

> ... a clever programmer can find a sequence of instructions written
in machine code which utilizes special properties of the instruction
set and available resources and which executes the program more
efficiently than the code that could be generated by any reasonable
compiler.

Of course technology has improved significantly almost fifty years
later, but the example he gave illustrates the amazing insight and
beauty of software implemented under tight memory and processing
constraints. Specifically, to solve the problem of converting a
hexadecimal digit to its ASCII representation, he presented this
example in 8080 assembly language:

    ADI  A,90H  ; A + 90H
    DAA         ; decimal adjust
    ACI  A,40H  ; A + 40H + carry
    DAA         ; decimal adjust

Lance Leventhal, in his excellent book ["6809 Assembly Language Programming", McGraw Hill, 1981](https://colorcomputerarchive.com/repo/Documents/Books/6809%20Assembly%20Language%20Programming%20%28Lance%20Leventhal%29.pdf)
in section 7-1, cited Allison's article and then recasted the example
into 6809 assembly language. The 6809 assembly code seen below is
virtually the same as that for the 8080.

    ADDA  #$90  ; decimal add $90 BCD
    DAA
    ADCA  #$40  ; decimal add $40 BCD + carry
    DAA

This article examines how this works which Leventhal left as an
exercise for the reader.

## Binary Coded Decimal
An eight-bit binary number represents the integer range from 0 to
255, or in hexadecimal notation, $00 to $FF. In many applications,
a decimal representation is desired instead where each eight bits,
or byte, is broken into an upper and lower four-bit nibble. These
nibbles are used to represent integers in the range $00 to $99.
Binary coded decimal (BCD) is the formal name for representing
numbers this way.  Here are some examples:

| Integer | Hexadecimal | BCD |
| ------- | ----------- | --- |
|     0   |     $00     | $00 |
|    17   |     $11     | $17 |
|    42   |     $2A     | $42 |
|    54   |     $36     | $54 |

Mathematical operations on eight-bit BCD numbers must adjust results
to maintain the BCD encodings. The 6809 microprocessor provides a
decimal adjust A accumulator instruction, DAA, that does just that.
The DAA instruction utilizes and sets two flags, the half-carry
flag (H) and the carry flag (C). From Leventhal, if the sum of two
BCD digits is between 10 and 15, inclusive, in a nibble then six
must be added to correct the BCD representation. This is illustrated
below.

```
     0101 ($5)
    +1000 ($8)
    -----
     1101 ($d)
    +0110 ($6) <-- decimal adjust by adding 6
    -----
0001 0011 (BCD $13)
```

An example where a half-carry occurs, resulting in both nibbles
being adjusted, would look like this:

```
     1001 0101  ($95)
    +0000 1000  ($08)
    ----------
     1001 1101  ($9d)
    +0000 0110  ($06) <-- adjust the lower nibble first
    ----------
     1010 0011  ($a3) <-- half carry from lower nibble to upper nibble occurs
    +0110 0000  ($60) <-- adjust upper nibble
    ----------
   1 0001 0011 ($103) <-- correct BCD representation of 95+8=103.
```

In the last example, the eight-bit BCD representation would be $03
with the carry bit set. As can be seen from the prior examples, the
DAA instruction adds either $00, $06, $60, or $66 to the result of
an eight-bit binary addition in order to provide the correct BCD
representation of the result.

## Converting hexadecimal to ASCII
So, given a hex digit of $00 to $0f in accumulator A, how does the
following 6809 assembly code work?

    adda  #$90  ; add $90 to the current accumulator value
    daa         ; adjust result to be correct BCD
    adca  #$40  ; add $40 plus previous carry from DAA
    daa         ; adjust result to be correct BCD

The following table shows our goal of the ASCII code for each of
the hexadecimal values.

| hexadecimal | ASCII |
| ----------- | ----- |
|     $00     |  $30  |
|     $01     |  $31  |
|     $02     |  $32  |
|     $03     |  $33  |
|     $04     |  $34  |
|     $05     |  $35  |
|     $06     |  $36  |
|     $07     |  $37  |
|     $08     |  $38  |
|     $09     |  $39  |
|     $0a     |  $41  |
|     $0b     |  $42  |
|     $0c     |  $43  |
|     $0d     |  $44  |
|     $0e     |  $45  |
|     $0f     |  $46  |

The first thing to notice is that all of the ASCII codes match the
BCD format where there are no nibbles in the range $a to $f. The
second thing to notice is that there are seven intervening ASCII
character encodings between an ASCII '9' ($39) and an ASCII 'A'
($41). This separates the desired goal into the ranges $30 to $39
and $41 to $46. The above table will be updated to show the results
of the instructions as we walk through them.

Let's begin with the first operation which is to perform BCD addition
of $90 to the value in the accumulator. For the first ten values,
this is a normal BCD addition and no adjustment is required. For
the last six values, we are performing a BCD addition on non-BCD
numbers so the results will be adjusted after. The following
instructions

    adda  #$90  ; add $90 to the current accumulator value
    daa         ; adjust result to be correct BCD

create the intermediate results shown below where an asterisk
indicates that the carry flag was set.

| hexadecimal | Add $90 BCD | ASCII |
| ----------- | ----------- | ----- |
|     $00     |     $90     |  $30  |
|     $01     |     $91     |  $31  |
|     $02     |     $92     |  $32  |
|     $03     |     $93     |  $33  |
|     $04     |     $94     |  $34  |
|     $05     |     $95     |  $35  |
|     $06     |     $96     |  $36  |
|     $07     |     $97     |  $37  |
|     $08     |     $98     |  $38  |
|     $09     |     $99     |  $39  |
|     $0a     |     $00*    |  $41  |
|     $0b     |     $01*    |  $42  |
|     $0c     |     $02*    |  $43  |
|     $0d     |     $03*    |  $44  |
|     $0e     |     $04*    |  $45  |
|     $0f     |     $05*    |  $46  |

The first add results in the values from $00 to $0f becoming $90
to $9f. Neither the half carry nor the carry flag is set. DAA will
do nothing with the values from $90 to $99 since they already meet
the requirements for BCD. DAA will add six to the lower nibble and
six to the upper nibble (so +$66) for all values between $9a and
$9f. So $9a to $9f will become $00 to $05 with the carry flag set.
The reason that $66 is added is because $6 is added to the lower
nibble (which is $a to $f) and that causes a half-carry into the
upper nibble with a resulting $a which then has a $6 added to it
to get it back to a BCD representation.

You should notice in the above table that now adding $40 BCD to the
prior result gets us to the correct ASCII representation of the
hexadecimal digits. The following instructions

    adca  #$40  ; add $40 plus previous carry from DAA
    daa         ; adjust result to be correct BCD

create the final results shown below where an asterisk indicates
that the carry flag was set.

| hexadecimal | Add $90 BCD | ASCII (after adding $40 BCD with carry) |
| ----------- | ----------- | --------------------------------------- |
|     $00     |     $90     |                   $30*                  |
|     $01     |     $91     |                   $31*                  |
|     $02     |     $92     |                   $32*                  |
|     $03     |     $93     |                   $33*                  |
|     $04     |     $94     |                   $34*                  |
|     $05     |     $95     |                   $35*                  |
|     $06     |     $96     |                   $36*                  |
|     $07     |     $97     |                   $37*                  |
|     $08     |     $98     |                   $38*                  |
|     $09     |     $99     |                   $39*                  |
|     $0a     |     $00*    |                   $41                   |
|     $0b     |     $01*    |                   $42                   |
|     $0c     |     $02*    |                   $43                   |
|     $0d     |     $03*    |                   $44                   |
|     $0e     |     $04*    |                   $45                   |
|     $0f     |     $05*    |                   $46                   |

The next add with carry (ADCA) of $40 results in the values $90 to
$99 becoming $d0 to $d9 since the carry was cleared from the previous
add of $90 BCD. The DAA instruction will add $60 to those results,
adjusting the values to $30 through $39 with the carry bit set after
the operation. These are the correct ASCII codes for the hexadecimal
digits of $0 through $9.

Adding $40 with the previous carry to the values $00 through $05
creates the desired ASCII codes for the hexadecimal digits of $a
through $f. The DAA instruction does nothing since the results are
properly formatted BCD numbers.

## Conclusion
Compiling the assembly code snippet with [lwasm](http://www.lwtools.ca/)
using this command

    lwasm -9l -p c snippet.asm

to generate 6809 machine language with a listing including cycle
counts yields the following:

```
0000 8B90    (snippet.asm):00001 [2]    adda  #$90  ; add $90 to the current accumulator value
0002 19      (snippet.asm):00002 [2]    daa         ; adjust result to be correct BCD
0003 8940    (snippet.asm):00003 [2]    adca  #$40  ; add $40 plus previous carry from DAA
0005 19      (snippet.asm):00004 [2]    daa         ; adjust result to be correct BCD
```

The assembly code from Allison and Leventhal requires six bytes and
takes eight clock cycles for the hexadecimal to ASCII conversion.
This code correctly and very efficiently converts the hexadecimal
values from $00 to $0f to the ASCII equivalent characters from '0'
to 'F' with no branching.

This repository includes a simple assembly language subroutine,
[hex2ascii.asm](hex2ascii.asm), that leverages the above to convert
both hexadecimal nibbles of a byte to their respective ASCII
characters.
